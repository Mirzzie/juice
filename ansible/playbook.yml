---
- name: IAST vs RASP Comparative Benchmark - Simplified Setup
  hosts: juiceshop
  become: true
  gather_facts: true

  vars:
    juice_shop_dir: /opt/juice-shop
    benchmark_tools_dir: /opt/benchmark-tools
    node_version: "22"

  vars_files:
    - secrets.yml

  tasks:
    # =======================================================================
    # SYSTEM PREPARATION
    # =======================================================================
    - name: Update APT cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required system packages
      apt:
        name:
          - curl
          - wget
          - git
          - unzip
          - software-properties-common
          - apt-transport-https
          - ca-certificates
          - gnupg
          - jq
          - bc
          - python3
          - python3-pip
        state: present

    # =======================================================================
    # DOCKER INSTALLATION
    # =======================================================================
    - name: Create keyrings directory
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Add Docker GPG key
      ansible.builtin.get_url:
        url: https://download.docker.com/linux/ubuntu/gpg
        dest: /etc/apt/keyrings/docker.asc
        mode: '0644'

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        filename: docker

    - name: Install Docker
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-compose-plugin
        state: present
        update_cache: yes

    - name: Add ubuntu user to docker group
      user:
        name: ubuntu
        groups: docker
        append: yes

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes

    # =======================================================================
    # FIREWALL CONFIGURATION
    # =======================================================================
    - name: Install UFW
      apt:
        name: ufw
        state: present

    - name: Configure UFW defaults
      ufw:
        direction: "{{ item.direction }}"
        policy: "{{ item.policy }}"
      loop:
        - { direction: 'incoming', policy: 'deny' }
        - { direction: 'outgoing', policy: 'allow' }

    - name: Allow essential ports
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - '22'      # SSH
        - '3000'    # Juice Shop
        - '8126'    # DataDog Agent
        - '8000'    # Prometheus Exporter
        - '9090'    # Prometheus
        - '3001'    # Grafana

    - name: Enable UFW
      ufw:
        state: enabled

    # =======================================================================
    # DATADOG AGENT INSTALLATION (IAST)
    # =======================================================================
    - name: Check if DataDog agent exists
      stat:
        path: /etc/datadog-agent/datadog.yaml
      register: datadog_installed

    - name: Install DataDog Agent
      block:
        - name: Download DataDog installation script
          get_url:
            url: "https://install.datadoghq.com/scripts/install_script_agent7.sh"
            dest: /tmp/install_datadog.sh
            mode: '0755'

        - name: Install DataDog Agent
          shell: >
            DD_API_KEY={{ datadog_api_key }} DD_SITE={{ datadog_site }} bash /tmp/install_datadog.sh
          args:
            creates: /etc/datadog-agent/datadog.yaml
          register: datadog_install
          retries: 3
          delay: 15
          until: datadog_install.rc == 0

        - name: Wait for DataDog config file
          wait_for:
            path: /etc/datadog-agent/datadog.yaml
            timeout: 60
      when: not datadog_installed.stat.exists

    - name: Configure DataDog for IAST detection
      blockinfile:
        path: /etc/datadog-agent/datadog.yaml
        block: |
          # DataDog IAST Configuration
          apm_config:
            enabled: true
            apm_non_local_traffic: true
            receiver_port: 8126
            receiver_timeout: 10
            max_traces_per_second: 100

          # IAST (Interactive Application Security Testing)
          appsec_config:
            enabled: true

          runtime_security_config:
            enabled: true

          logs_enabled: true
          logs_config:
            container_collect_all: true
        marker: "# {mark} IAST CONFIGURATION"
        create: no
        backup: yes
      notify: Restart DataDog Agent

    - name: Ensure DataDog Agent is running
      systemd:
        name: datadog-agent
        state: started
        enabled: yes

    # =======================================================================
    # APPLICATION SETUP (JUICE SHOP WITH IAST & RASP)
    # =======================================================================
    - name: Create application directory
      file:
        path: "{{ juice_shop_dir }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Clone Juice Shop repository
      git:
        repo: https://github.com/juice-shop/juice-shop.git
        dest: "{{ juice_shop_dir }}"
        depth: 1
        update: yes
        force: yes
      become: true
      become_user: ubuntu

    - name: Create DataDog tracer file
      copy:
        dest: "{{ juice_shop_dir }}/tracer.ts"
        content: |
          // DataDog APM & IAST Tracer
          import tracer from 'dd-trace';
          tracer.init({
            logInjection: true,
            profiling: true,
            runtimeMetrics: true
          });
          export default tracer;
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Create Dockerfile with IAST and RASP instrumentation
      copy:
        dest: "{{ juice_shop_dir }}/Dockerfile"
        content: |
          FROM node:{{ node_version }}-bookworm-slim AS builder

          RUN apt-get update && apt-get install -y git python3 make g++ && rm -rf /var/lib/apt/lists/*
          WORKDIR /juice-shop

          # Clone Juice Shop
          RUN git clone --depth 1 https://github.com/juice-shop/juice-shop.git . && rm -rf .git
          
          # Install base dependencies
          RUN npm install
          
          # Install security tools: DataDog (IAST) and Aikido (RASP)
          RUN npm install @aikidosec/firewall dd-trace

          # Copy tracer configuration
          COPY tracer.ts ./tracer.ts

          # Instrument application with DataDog (IAST) and Aikido (RASP)
          RUN sed -i "1i import './tracer' // DataDog IAST" app.ts && \
              sed -i "2i import '@aikidosec/firewall' // Aikido RASP" app.ts && \
              sed -i "1i import './tracer' // DataDog IAST" server.ts && \
              sed -i "2i import '@aikidosec/firewall' // Aikido RASP" server.ts

          # Build TypeScript
          RUN npx tsc || npm run build:server || echo "TypeScript compilation attempted"
          
          # Verify instrumentation
          RUN echo "=== Verifying Instrumentation ===" && \
              grep -E "tracer|aikido" build/app.js | head -5 || echo "Instrumentation check skipped"

          # Build frontend
          RUN cd frontend && npm install --legacy-peer-deps && \
              node ./node_modules/@angular/cli/bin/ng build --configuration production || echo "Frontend built"

          # Production image
          FROM node:{{ node_version }}-bookworm-slim
          
          RUN apt-get update && apt-get install -y curl procps && rm -rf /var/lib/apt/lists/*
          RUN groupadd -r juiceshop && useradd -r -g juiceshop juiceshop
          
          WORKDIR /juice-shop

          COPY --from=builder --chown=juiceshop:juiceshop /juice-shop /juice-shop

          RUN mkdir -p /juice-shop/logs /juice-shop/ftp /juice-shop/data && \
              chown -R juiceshop:juiceshop /juice-shop

          USER juiceshop
          EXPOSE 3000

          HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
            CMD curl -f http://localhost:3000/rest/admin/application-version || exit 1

          ENV NODE_ENV=production \
              PORT=3000 \
              NODE_OPTIONS="--max-old-space-size=3072"
          
          CMD ["npm", "start"]
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Pre-build Docker image
      shell: |
        cd {{ juice_shop_dir }}
        sg docker -c "docker build -t juice-shop-secure:latest ."
      become: true
      become_user: ubuntu
      async: 1800
      poll: 15
      register: docker_build

    - name: Create docker-compose template
      copy:
        dest: "{{ juice_shop_dir }}/docker-compose.yml"
        content: |
          services:
            juice-shop:
              image: juice-shop-secure:latest
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                DD_ENV: "${SECURITY_MODE:-baseline}"
                DD_SERVICE: juice-shop
                DD_VERSION: latest
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                DD_PROFILING_ENABLED: "true"
                DD_RUNTIME_METRICS_ENABLED: "true"
                DD_DATA_STREAMS_ENABLED: "true"
                # IAST Configuration (DataDog)
                DD_APPSEC_ENABLED: "${DD_APPSEC_ENABLED:-false}"
                DD_IAST_ENABLED: "${DD_IAST_ENABLED:-false}"
                # RASP Configuration (Aikido Zen)
                AIKIDO_TOKEN: "${AIKIDO_TOKEN}"
                AIKIDO_BLOCK: "${AIKIDO_BLOCK:-false}"
                AIKIDO_DEBUG: "true"
              env_file:
                - .env
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
              logging:
                driver: "json-file"
                options:
                  max-size: "10m"
                  max-file: "3"
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Create .env file
      copy:
        dest: "{{ juice_shop_dir }}/.env"
        content: |
          AIKIDO_TOKEN={{ aikido_token }}
          AIKIDO_BLOCK=false
          DD_APPSEC_ENABLED=false
          DD_IAST_ENABLED=false
          SECURITY_MODE=baseline
        owner: ubuntu
        group: ubuntu
        mode: '0600'
      no_log: true

    # =======================================================================
    # DAST ATTACK SCRIPTS (Attack Traffic Generator)
    # =======================================================================
    - name: Create benchmark tools directory
      file:
        path: "{{ benchmark_tools_dir }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0750'

    - name: Install Python packages for metrics
      pip:
        name:
          - prometheus-client
          - pandas
        break_system_packages: yes
      ignore_errors: true

    - name: Create SQL Injection DAST script
      copy:
        dest: "{{ benchmark_tools_dir }}/sqli_attacks.sh"
        content: |
          #!/bin/bash
          # DAST: SQL Injection Attack Generator
          
          TARGET=$1
          OUTPUT_FILE=$2
          
          echo "üéØ Running SQL Injection attacks (DAST) against $TARGET"
          
          ATTACK_COUNT=0
          DETECTED_COUNT=0
          BLOCKED_COUNT=0
          
          # Wait for application
          for i in {1..10}; do
            if curl -f -s "$TARGET" > /dev/null 2>&1; then
              echo "‚úÖ Target ready"
              break
            fi
            sleep 3
          done
          
          # SQLi Payload 1: Classic OR bypass
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$TARGET/rest/user/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@juice-sh.op'"'"' OR '"'"'1'"'"'='"'"'1","password":"test"}' 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          if [[ "$HTTP_CODE" == "403" ]] || [[ "$BODY" == *"blocked"* ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: ' OR '1'='1"
          elif [[ "$HTTP_CODE" == "401" ]] || [[ "$HTTP_CODE" == "400" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: ' OR '1'='1"
          else
            echo "  ‚ùå BYPASSED: ' OR '1'='1 (HTTP $HTTP_CODE)"
          fi
          sleep 1
          
          # SQLi Payload 2: Comment bypass
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$TARGET/rest/user/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@juice-sh.op'"'"' OR 1=1--","password":"test"}' 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: ' OR 1=1--"
          elif [[ "$HTTP_CODE" == "401" ]] || [[ "$HTTP_CODE" == "400" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: ' OR 1=1--"
          else
            echo "  ‚ùå BYPASSED: ' OR 1=1--"
          fi
          sleep 1
          
          # SQLi Payload 3: UNION SELECT
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$TARGET/rest/user/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"1'"'"' UNION SELECT NULL--","password":"test"}' 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: UNION SELECT"
          elif [[ "$HTTP_CODE" == "401" ]] || [[ "$HTTP_CODE" == "400" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: UNION SELECT"
          else
            echo "  ‚ùå BYPASSED: UNION SELECT"
          fi
          sleep 1
          
          # SQLi Payload 4: Tautology
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$TARGET/rest/user/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@juice-sh.op'"'"' OR '"'"'a'"'"'='"'"'a","password":"test"}' 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: ' OR 'a'='a"
          elif [[ "$HTTP_CODE" == "401" ]] || [[ "$HTTP_CODE" == "400" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: ' OR 'a'='a"
          else
            echo "  ‚ùå BYPASSED: ' OR 'a'='a"
          fi
          sleep 1
          
          # SQLi Payload 5: Inline comment
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$TARGET/rest/user/login" \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@juice-sh.op'"'"'/*","password":"test"}' 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: admin'/*"
          elif [[ "$HTTP_CODE" == "401" ]] || [[ "$HTTP_CODE" == "400" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: admin'/*"
          else
            echo "  ‚ùå BYPASSED: admin'/*"
          fi
          
          echo ""
          echo "üìä SQL Injection DAST Results: $ATTACK_COUNT attacks | $DETECTED_COUNT detected | $BLOCKED_COUNT blocked"
          echo "$ATTACK_COUNT,$DETECTED_COUNT,$BLOCKED_COUNT" > "$OUTPUT_FILE"
        owner: ubuntu
        group: ubuntu
        mode: '0750'

    - name: Create XSS DAST script
      copy:
        dest: "{{ benchmark_tools_dir }}/xss_attacks.sh"
        content: |
          #!/bin/bash
          # DAST: XSS Attack Generator
          
          TARGET=$1
          OUTPUT_FILE=$2
          
          echo "üéØ Running XSS attacks (DAST) against $TARGET"
          
          ATTACK_COUNT=0
          DETECTED_COUNT=0
          BLOCKED_COUNT=0
          
          # XSS Payload 1: Script tag
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/rest/products/search?q=%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          if [[ "$HTTP_CODE" == "403" ]] || [[ "$BODY" == *"blocked"* ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: <script> tag"
          elif [[ "$BODY" != *"<script>"* ]] && [[ "$HTTP_CODE" == "200" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: <script> sanitized"
          else
            echo "  ‚ùå BYPASSED: <script> tag"
          fi
          sleep 1
          
          # XSS Payload 2: Image onerror
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/rest/products/search?q=%3Cimg%20src%3Dx%20onerror%3Dalert%28%27XSS%27%29%3E" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: <img> onerror"
          elif [[ $(echo "$RESPONSE" | head -n -1 | grep -c "onerror") -eq 0 ]] && [[ "$HTTP_CODE" == "200" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: <img> sanitized"
          else
            echo "  ‚ùå BYPASSED: <img> onerror"
          fi
          sleep 1
          
          # XSS Payload 3: SVG onload
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/rest/products/search?q=%3Csvg%2Fonload%3Dalert%28%27XSS%27%29%3E" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: <svg> onload"
          elif [[ $(echo "$RESPONSE" | head -n -1 | grep -c "onload") -eq 0 ]] && [[ "$HTTP_CODE" == "200" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: <svg> sanitized"
          else
            echo "  ‚ùå BYPASSED: <svg> onload"
          fi
          sleep 1
          
          # XSS Payload 4: JavaScript protocol
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/rest/products/search?q=javascript%3Aalert%28%27XSS%27%29" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: javascript: protocol"
          else
            echo "  ‚ùå BYPASSED: javascript: protocol"
          fi
          sleep 1
          
          # XSS Payload 5: Iframe injection
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/rest/products/search?q=%3Ciframe%20src%3D%27javascript%3Aalert%281%29%27%3E" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: <iframe> javascript"
          elif [[ $(echo "$RESPONSE" | head -n -1 | grep -c "<iframe") -eq 0 ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: <iframe> sanitized"
          else
            echo "  ‚ùå BYPASSED: <iframe>"
          fi
          
          echo ""
          echo "üìä XSS DAST Results: $ATTACK_COUNT attacks | $DETECTED_COUNT detected | $BLOCKED_COUNT blocked"
          echo "$ATTACK_COUNT,$DETECTED_COUNT,$BLOCKED_COUNT" > "$OUTPUT_FILE"
        owner: ubuntu
        group: ubuntu
        mode: '0750'

    - name: Create Path Traversal DAST script
      copy:
        dest: "{{ benchmark_tools_dir }}/path_traversal.sh"
        content: |
          #!/bin/bash
          # DAST: Path Traversal Attack Generator
          
          TARGET=$1
          OUTPUT_FILE=$2
          
          echo "üéØ Running Path Traversal attacks (DAST) against $TARGET"
          
          ATTACK_COUNT=0
          DETECTED_COUNT=0
          BLOCKED_COUNT=0
          
          # Path Traversal 1: Classic
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/ftp/..%2F..%2F..%2Fetc%2Fpasswd" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          if [[ "$HTTP_CODE" == "403" ]] || [[ "$BODY" == *"blocked"* ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: ../../../etc/passwd"
          elif [[ "$HTTP_CODE" == "404" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: Path blocked"
          elif [[ "$BODY" == *"root:"* ]]; then
            echo "  ‚ùå BYPASSED: /etc/passwd accessed!"
          else
            echo "  ‚ö†Ô∏è  INCONCLUSIVE"
          fi
          sleep 1
          
          # Path Traversal 2: Double encoded
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/ftp/..%252f..%252f..%252fetc%252fpasswd" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: double encoded"
          elif [[ "$HTTP_CODE" == "404" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: Path blocked"
          else
            echo "  ‚ùå BYPASSED: double encoded"
          fi
          sleep 1
          
          # Path Traversal 3: Many levels
          ATTACK_COUNT=$((ATTACK_COUNT + 1))
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "$TARGET/ftp/..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd" 2>&1 || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          if [[ "$HTTP_CODE" == "403" ]]; then
            BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
            echo "  ‚úÖ BLOCKED: many levels"
          elif [[ "$HTTP_CODE" == "404" ]]; then
            DETECTED_COUNT=$((DETECTED_COUNT + 1))
            echo "  ‚ö†Ô∏è  DETECTED: Path blocked"
          else
            echo "  ‚ùå BYPASSED: many levels"
          fi
          
          echo ""
          echo "üìä Path Traversal DAST Results: $ATTACK_COUNT attacks | $DETECTED_COUNT detected | $BLOCKED_COUNT blocked"
          echo "$ATTACK_COUNT,$DETECTED_COUNT,$BLOCKED_COUNT" > "$OUTPUT_FILE"
        owner: ubuntu
        group: ubuntu
        mode: '0750'

    - name: Create master DAST orchestrator
      copy:
        dest: "{{ benchmark_tools_dir }}/run_all_attacks.sh"
        content: |
          #!/bin/bash
          # Master DAST Attack Orchestrator
          
          TARGET=$1
          CONFIG_NAME=$2
          RESULTS_DIR=$3
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üöÄ DAST Attack Suite"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "Target: $TARGET"
          echo "Security Mode: $CONFIG_NAME"
          echo "Results: $RESULTS_DIR"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          mkdir -p "$RESULTS_DIR"
          START_TIME=$(date +%s)
          
          # Run all DAST attacks
          {{ benchmark_tools_dir }}/sqli_attacks.sh "$TARGET" "$RESULTS_DIR/sqli_results.csv"
          {{ benchmark_tools_dir }}/xss_attacks.sh "$TARGET" "$RESULTS_DIR/xss_results.csv"
          {{ benchmark_tools_dir }}/path_traversal.sh "$TARGET" "$RESULTS_DIR/path_results.csv"
          
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          # Create summary
          echo "ATTACK_TYPE,TOTAL,DETECTED,BLOCKED" > "$RESULTS_DIR/summary.csv"
          [ -f "$RESULTS_DIR/sqli_results.csv" ] && echo -n "SQL_INJECTION," >> "$RESULTS_DIR/summary.csv" && cat "$RESULTS_DIR/sqli_results.csv" >> "$RESULTS_DIR/summary.csv"
          [ -f "$RESULTS_DIR/xss_results.csv" ] && echo -n "XSS," >> "$RESULTS_DIR/summary.csv" && cat "$RESULTS_DIR/xss_results.csv" >> "$RESULTS_DIR/summary.csv"
          [ -f "$RESULTS_DIR/path_results.csv" ] && echo -n "PATH_TRAVERSAL," >> "$RESULTS_DIR/summary.csv" && cat "$RESULTS_DIR/path_results.csv" >> "$RESULTS_DIR/summary.csv"
          echo "DURATION_SECONDS,$DURATION" >> "$RESULTS_DIR/summary.csv"
          
          echo ""
          echo "‚úÖ DAST suite completed in ${DURATION}s"
        owner: ubuntu
        group: ubuntu
        mode: '0750'

    # =======================================================================
    # CONTINUOUS BENCHMARK SYSTEM (Daily Rotation)
    # =======================================================================
    - name: Create benchmark results directory
      file:
        path: /var/lib/benchmark-results
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create continuous benchmark orchestrator
      copy:
        dest: /opt/benchmark-tools/continuous_iast_rasp_benchmark.py
        content: |
          #!/usr/bin/env python3
          """
          Continuous IAST vs RASP Benchmark
          Rotates between IAST-only and RASP configurations
          Runs DAST attacks continuously
          """
          
          import subprocess
          import time
          import json
          import os
          from datetime import datetime
          import logging
          import signal
          import sys
          
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.FileHandler('/var/log/iast_rasp_benchmark.log'),
                  logging.StreamHandler()
              ]
          )
          logger = logging.getLogger(__name__)
          
          class IASTvsRASPBenchmark:
              def __init__(self):
                  # Only two configurations to compare
                  self.configurations = [
                      {
                          'name': 'iast-detection',
                          'display_name': 'DataDog IAST (Detection Only)',
                          'dd_appsec': 'true',
                          'dd_iast': 'true',
                          'aikido_block': 'false',
                          'env_file_content': 'SECURITY_MODE=iast-detection\nDD_APPSEC_ENABLED=true\nDD_IAST_ENABLED=true\nAIKIDO_BLOCK=false'
                      },
                      {
                          'name': 'rasp-protection',
                          'display_name': 'Aikido RASP (Detection + Blocking)',
                          'dd_appsec': 'false',
                          'dd_iast': 'false',
                          'aikido_block': 'true',
                          'env_file_content': 'SECURITY_MODE=rasp-protection\nDD_APPSEC_ENABLED=false\nDD_IAST_ENABLED=false\nAIKIDO_BLOCK=true'
                      }
                  ]
                  self.current_config_index = 0
                  self.running = True
                  self.results_base = '/var/lib/benchmark-results'
                  self.rotation_interval = 3600  # 1 hour per config
                  self.attack_interval = 300  # 5 minutes between attacks
                  
                  os.makedirs(self.results_base, exist_ok=True)
                  signal.signal(signal.SIGTERM, self.handle_shutdown)
                  signal.signal(signal.SIGINT, self.handle_shutdown)
              
              def handle_shutdown(self, signum, frame):
                  logger.info("Shutting down gracefully...")
                  self.running = False
                  sys.exit(0)
              
              def deploy_configuration(self, config):
                  """Deploy IAST or RASP configuration"""
                  logger.info(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                  logger.info(f"üîÑ Deploying: {config['display_name']}")
                  logger.info(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                  
                  # Update .env file
                  with open('/opt/juice-shop/.env', 'w') as f:
                      f.write(config['env_file_content'])
                  
                  # Restart application
                  subprocess.run(['docker', 'compose', '-f', '/opt/juice-shop/docker-compose.yml', 'down'], 
                                capture_output=True)
                  time.sleep(5)
                  subprocess.run(['docker', 'compose', '-f', '/opt/juice-shop/docker-compose.yml', 'up', '-d'], 
                                capture_output=True)
                  
                  # Wait for readiness
                  logger.info("‚è≥ Waiting for application startup...")
                  for i in range(30):
                      try:
                          result = subprocess.run(['curl', '-f', '-s', 'http://localhost:3000'], 
                                                capture_output=True, timeout=5)
                          if result.returncode == 0:
                              logger.info(f"‚úÖ {config['display_name']} is READY")
                              return True
                      except:
                          pass
                      time.sleep(5)
                  
                  logger.warning("‚ö†Ô∏è  Application startup delayed")
                  return False
              
              def run_dast_attacks(self, config_name):
                  """Run DAST attack suite"""
                  timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                  results_dir = f"{self.results_base}/{config_name}/{timestamp}"
                  os.makedirs(results_dir, exist_ok=True)
                  
                  logger.info(f"üéØ Running DAST attacks against {config_name}")
                  
                  # Run master attack script
                  try:
                      subprocess.run(['/opt/benchmark-tools/run_all_attacks.sh',
                                    'http://localhost:3000',
                                    config_name,
                                    results_dir],
                                   timeout=600,
                                   capture_output=True)
                      logger.info(f"‚úÖ DAST attacks completed")
                  except subprocess.TimeoutExpired:
                      logger.warning("‚ö†Ô∏è  DAST attacks timed out")
                  except Exception as e:
                      logger.error(f"‚ùå Error running DAST: {e}")
                  
                  # Extract container logs for detection analysis
                  try:
                      result = subprocess.run(['docker', 'logs', 'juice-shop'],
                                            capture_output=True,
                                            text=True,
                                            timeout=30)
                      
                      with open(f"{results_dir}/container.log", 'w') as f:
                          f.write(result.stdout)
                          f.write(result.stderr)
                      
                      # Count security events
                      log_text = result.stdout + result.stderr
                      blocked = log_text.lower().count('blocked')
                      detected = log_text.lower().count('detected') + log_text.lower().count('vulnerability')
                      
                      with open(f"{results_dir}/security_events.csv", 'w') as f:
                          f.write("METRIC,COUNT\n")
                          f.write(f"BLOCKED,{blocked}\n")
                          f.write(f"DETECTED,{detected}\n")
                      
                      logger.info(f"üìä Security Events: {detected} detected, {blocked} blocked")
                  except Exception as e:
                      logger.error(f"Error extracting logs: {e}")
                  
                  # Update latest symlink
                  latest_link = f"{self.results_base}/{config_name}/latest"
                  if os.path.lexists(latest_link):
                      os.remove(latest_link)
                  os.symlink(results_dir, latest_link)
                  
                  return results_dir
              
              def run_continuous_benchmark(self):
                  """Main continuous loop"""
                  logger.info("üöÄ Starting IAST vs RASP Continuous Benchmark")
                  
                  while self.running:
                      config = self.configurations[self.current_config_index]
                      
                      if self.deploy_configuration(config):
                          config_start_time = time.time()
                          attack_count = 0
                          
                          # Run attacks during this configuration window
                          while (time.time() - config_start_time) < self.rotation_interval and self.running:
                              attack_count += 1
                              self.run_dast_attacks(config['name'])
                              logger.info(f"‚úÖ Attack round {attack_count} completed")
                              
                              if self.running:
                                  time.sleep(self.attack_interval)
                      
                      # Rotate to next configuration
                      self.current_config_index = (self.current_config_index + 1) % len(self.configurations)
                      next_config = self.configurations[self.current_config_index]
                      logger.info(f"üîÑ Next up: {next_config['display_name']}")
          
          if __name__ == '__main__':
              benchmark = IASTvsRASPBenchmark()
              benchmark.run_continuous_benchmark()
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create systemd service for continuous benchmark
      copy:
        dest: /etc/systemd/system/iast-rasp-benchmark.service
        content: |
          [Unit]
          Description=IAST vs RASP Continuous Benchmark
          After=network.target docker.service datadog-agent.service
          Wants=docker.service
          
          [Service]
          Type=simple
          User=ubuntu
          Group=ubuntu
          SupplementaryGroups=docker
          WorkingDirectory=/opt/benchmark-tools
          ExecStart=/usr/bin/python3 /opt/benchmark-tools/continuous_iast_rasp_benchmark.py
          Restart=always
          RestartSec=30
          StandardOutput=append:/var/log/iast_rasp_benchmark.log
          StandardError=append:/var/log/iast_rasp_benchmark_error.log
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    # =======================================================================
    # PROMETHEUS + GRAFANA MONITORING
    # =======================================================================
    - name: Create monitoring directory
      file:
        path: /opt/monitoring
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create Prometheus metrics exporter
      copy:
        dest: /opt/monitoring/prometheus_exporter.py
        content: |
          #!/usr/bin/env python3
          """Prometheus Exporter for IAST vs RASP Metrics"""
          
          from prometheus_client import start_http_server, Gauge, Counter
          import time
          import json
          import os
          from pathlib import Path
          from datetime import datetime
          import logging
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
          
          # Metrics
          attack_total = Gauge('security_attack_total', 'Total attacks executed', ['config', 'attack_type'])
          attack_detected = Gauge('security_attack_detected', 'Attacks detected', ['config', 'attack_type'])
          attack_blocked = Gauge('security_attack_blocked', 'Attacks blocked', ['config', 'attack_type'])
          detection_rate = Gauge('security_detection_rate_percent', 'Detection rate percentage', ['config'])
          blocking_rate = Gauge('security_blocking_rate_percent', 'Blocking rate percentage', ['config'])
          iast_vs_rasp_advantage = Gauge('security_rasp_advantage_percent', 'RASP advantage over IAST')
          
          class MetricsExporter:
              def __init__(self):
                  self.results_base = Path('/var/lib/benchmark-results')
              
              def process_results(self):
                  """Process latest results and update metrics"""
                  for config in ['iast-detection', 'rasp-protection']:
                      latest_path = self.results_base / config / 'latest'
                      
                      if not latest_path.exists():
                          continue
                      
                      # Read summary CSV
                      summary_file = latest_path / 'summary.csv'
                      if summary_file.exists():
                          try:
                              with open(summary_file, 'r') as f:
                                  lines = f.readlines()[1:]  # Skip header
                              
                              total_attacks = 0
                              total_detected = 0
                              total_blocked = 0
                              
                              for line in lines:
                                  if 'DURATION' in line:
                                      continue
                                  
                                  parts = line.strip().split(',')
                                  if len(parts) >= 4:
                                      attack_type = parts[0]
                                      total = int(parts[1])
                                      detected = int(parts[2])
                                      blocked = int(parts[3])
                                      
                                      attack_total.labels(config=config, attack_type=attack_type).set(total)
                                      attack_detected.labels(config=config, attack_type=attack_type).set(detected)
                                      attack_blocked.labels(config=config, attack_type=attack_type).set(blocked)
                                      
                                      total_attacks += total
                                      total_detected += detected
                                      total_blocked += blocked
                              
                              # Calculate rates
                              if total_attacks > 0:
                                  detect_rate = ((total_detected + total_blocked) / total_attacks) * 100
                                  block_rate = (total_blocked / total_attacks) * 100
                                  
                                  detection_rate.labels(config=config).set(detect_rate)
                                  blocking_rate.labels(config=config).set(block_rate)
                                  
                                  logger.info(f"{config}: {detect_rate:.1f}% detection, {block_rate:.1f}% blocking")
                          
                          except Exception as e:
                              logger.error(f"Error processing {config}: {e}")
                  
                  # Calculate RASP advantage
                  try:
                      rasp_block = blocking_rate._metrics.get(('rasp-protection',), {}).get('value', 0)
                      iast_block = blocking_rate._metrics.get(('iast-detection',), {}).get('value', 0)
                      
                      if iast_block > 0:
                          advantage = ((rasp_block - iast_block) / iast_block) * 100
                      else:
                          advantage = 100 if rasp_block > 0 else 0
                      
                      iast_vs_rasp_advantage.set(advantage)
                      logger.info(f"RASP Advantage: {advantage:.1f}%")
                  except Exception as e:
                      logger.error(f"Error calculating advantage: {e}")
              
              def run(self, port=8000, interval=10):
                  """Run exporter"""
                  logger.info(f"Starting Prometheus exporter on port {port}")
                  start_http_server(port)
                  
                  while True:
                      try:
                          self.process_results()
                      except Exception as e:
                          logger.error(f"Error: {e}")
                      time.sleep(interval)
          
          if __name__ == '__main__':
              exporter = MetricsExporter()
              exporter.run(port=8000, interval=5)
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create Prometheus configuration
      copy:
        dest: /opt/monitoring/prometheus.yml
        content: |
          global:
            scrape_interval: 5s
            evaluation_interval: 5s
          
          scrape_configs:
            - job_name: 'iast-rasp-metrics'
              static_configs:
                - targets: ['host.docker.internal:8000']
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Create Grafana dashboard
      copy:
        dest: /opt/monitoring/dashboard.json
        content: |
          {
            "dashboard": {
              "title": "IAST vs RASP - Security Comparison",
              "tags": ["security", "iast", "rasp"],
              "timezone": "browser",
              "panels": [
                {
                  "id": 1,
                  "title": "üõ°Ô∏è Blocking Effectiveness",
                  "type": "bargauge",
                  "gridPos": {"x": 0, "y": 0, "w": 12, "h": 8},
                  "targets": [{
                    "expr": "security_blocking_rate_percent",
                    "legendFormat": "{{config}}"
                  }],
                  "fieldConfig": {
                    "defaults": {
                      "thresholds": {
                        "steps": [
                          {"value": 0, "color": "red"},
                          {"value": 50, "color": "yellow"},
                          {"value": 80, "color": "green"}
                        ]
                      },
                      "unit": "percent",
                      "max": 100
                    }
                  }
                },
                {
                  "id": 2,
                  "title": "üéØ Detection Rate Over Time",
                  "type": "timeseries",
                  "gridPos": {"x": 12, "y": 0, "w": 12, "h": 8},
                  "targets": [{
                    "expr": "security_detection_rate_percent",
                    "legendFormat": "{{config}}"
                  }],
                  "fieldConfig": {
                    "defaults": {
                      "unit": "percent",
                      "max": 100
                    }
                  }
                },
                {
                  "id": 3,
                  "title": "üèÜ RASP Advantage Over IAST",
                  "type": "stat",
                  "gridPos": {"x": 0, "y": 8, "w": 8, "h": 6},
                  "targets": [{
                    "expr": "security_rasp_advantage_percent"
                  }],
                  "fieldConfig": {
                    "defaults": {
                      "unit": "percent",
                      "thresholds": {
                        "steps": [
                          {"value": 0, "color": "yellow"},
                          {"value": 25, "color": "green"},
                          {"value": 50, "color": "dark-green"}
                        ]
                      }
                    }
                  }
                },
                {
                  "id": 4,
                  "title": "üìä Attack Results by Type",
                  "type": "table",
                  "gridPos": {"x": 8, "y": 8, "w": 16, "h": 6},
                  "targets": [
                    {
                      "expr": "security_attack_total",
                      "format": "table",
                      "legendFormat": "Total"
                    },
                    {
                      "expr": "security_attack_blocked",
                      "format": "table",
                      "legendFormat": "Blocked"
                    }
                  ]
                }
              ],
              "refresh": "10s",
              "time": {"from": "now-1h", "to": "now"}
            }
          }
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Create monitoring docker-compose
      copy:
        dest: /opt/monitoring/docker-compose.yml
        content: |
          version: '3.8'
          services:
            prometheus:
              image: prom/prometheus:latest
              container_name: prometheus
              restart: unless-stopped
              ports:
                - "9090:9090"
              volumes:
                - ./prometheus.yml:/etc/prometheus/prometheus.yml
                - prometheus-data:/prometheus
              command:
                - '--config.file=/etc/prometheus/prometheus.yml'
                - '--storage.tsdb.retention.time=30d'
              extra_hosts:
                - "host.docker.internal:host-gateway"
            
            grafana:
              image: grafana/grafana:latest
              container_name: grafana
              restart: unless-stopped
              ports:
                - "3001:3000"
              environment:
                - GF_SECURITY_ADMIN_USER=admin
                - GF_SECURITY_ADMIN_PASSWORD=iast_rasp_2024
                - GF_USERS_ALLOW_SIGN_UP=false
              volumes:
                - grafana-data:/var/lib/grafana
              depends_on:
                - prometheus
          
          volumes:
            prometheus-data:
            grafana-data:
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    # =======================================================================
    # STARTUP SCRIPT
    # =======================================================================
    - name: Create startup script
      copy:
        dest: /opt/benchmark-tools/start_iast_rasp_system.sh
        content: |
          #!/bin/bash
          set -e
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üöÄ Starting IAST vs RASP Benchmark System"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Start monitoring stack
          echo "üìä Starting Prometheus + Grafana..."
          cd /opt/monitoring
          sg docker -c "docker compose down" 2>/dev/null || true
          sg docker -c "docker compose up -d"
          
          # Start metrics exporter
          echo "üìà Starting metrics exporter..."
          pkill -f prometheus_exporter.py 2>/dev/null || true
          nohup python3 /opt/monitoring/prometheus_exporter.py > /tmp/prometheus_exporter.log 2>&1 &
          echo $! > /tmp/prometheus_exporter.pid
          
          sleep 10
          
          # Verify services
          sg docker -c "docker ps" | grep -q prometheus && echo "‚úÖ Prometheus: UP" || echo "‚ùå Prometheus: DOWN"
          sg docker -c "docker ps" | grep -q grafana && echo "‚úÖ Grafana: UP" || echo "‚ùå Grafana: DOWN"
          pgrep -f prometheus_exporter.py > /dev/null && echo "‚úÖ Exporter: UP" || echo "‚ùå Exporter: DOWN"
          
          PUBLIC_IP=$(curl -s ifconfig.me 2>/dev/null || echo "YOUR_IP")
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä Access Your Dashboards:"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "Grafana: http://$PUBLIC_IP:3001"
          echo "  Username: admin"
          echo "  Password: iast_rasp_2024"
          echo ""
          echo "Prometheus: http://$PUBLIC_IP:9090"
          echo "Metrics: http://$PUBLIC_IP:8000/metrics"
          echo ""
          echo "‚úÖ System Ready!"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Start monitoring stack
      shell: |
        cd /opt/benchmark-tools
        nohup ./start_iast_rasp_system.sh > /tmp/monitoring_startup.log 2>&1 &
      become: true
      become_user: ubuntu
      async: 300
      poll: 0

    - name: Wait for monitoring initialization
      pause:
        seconds: 30

    - name: Enable and start continuous benchmark service
      systemd:
        name: iast-rasp-benchmark
        state: started
        enabled: yes
        daemon_reload: yes

    - name: Display access information
      debug:
        msg: |
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚úÖ IAST vs RASP Benchmark System Deployed!
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          
          üìä Grafana: http://{{ ansible_default_ipv4.address }}:3001
             Username: admin
             Password: iast_rasp_2024
          
          üìà Prometheus: http://{{ ansible_default_ipv4.address }}:9090
          üìä Metrics: http://{{ ansible_default_ipv4.address }}:8000/metrics
          
          üîÑ System automatically rotates between:
             1. DataDog IAST (Detection Only)
             2. Aikido RASP (Detection + Blocking)
          
          ‚è±Ô∏è  Rotation: Every 60 minutes
          üéØ DAST Attacks: Every 5 minutes
          
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  handlers:
    - name: Restart DataDog Agent
      systemd:
        name: datadog-agent
        state: restarted