#!/usr/bin/env python3
"""
Thesis Log Telemetry Exporter
- Connects to Docker Socket to read Juice Shop logs.
- Regex matches Datadog IAST and Aikido RASP events in Real-Time.
- Zero Latency. Zero External API Calls.
"""
import time
import json
import os
import docker
import threading
from prometheus_client import start_http_server, Gauge, Counter

# ============= CONFIGURATION =============
METRICS_DIR = '/opt/security-metrics/data'
SCENARIO_FILE = os.path.join(METRICS_DIR, 'scenario_info.json')
SEMGREP_FILE = os.path.join(METRICS_DIR, 'semgrep-results.json')
JUICE_CONTAINER_NAME = 'juice-shop'

# ============= METRICS =============
SCENARIO_GAUGE = Gauge('thesis_scenario_id', 'Current Thesis Scenario (1=Baseline, 2=Detect, 3=Block)')
SAST_GAUGE = Gauge('thesis_sast_vulns', 'SAST Vulnerabilities', ['severity'])

# REAL-TIME LOG COUNTERS
IAST_DETECTIONS = Counter('thesis_iast_detections_total', 'Real-time detections by Datadog IAST')
RASP_DETECTIONS = Counter('thesis_rasp_detections_total', 'Real-time detections by Aikido RASP')
RASP_BLOCKS = Counter('thesis_rasp_blocks_total', 'Real-time BLOCKS by Aikido RASP')

# ============= LOGIC =============

def update_scenario_metrics():
    """Reads the JSON file generated by the shell script"""
    try:
        if os.path.exists(SCENARIO_FILE):
            with open(SCENARIO_FILE, 'r') as f:
                data = json.load(f)
                SCENARIO_GAUGE.set(data.get('scenario_id', 0))
    except Exception:
        pass

def update_sast_metrics():
    """Reads Semgrep results once at startup"""
    try:
        if os.path.exists(SEMGREP_FILE):
            with open(SEMGREP_FILE, 'r') as f:
                data = json.load(f)
                results = data.get('results', [])
                high, medium = 0, 0
                for res in results:
                    sev = res.get('extra', {}).get('severity', 'INFO')
                    if sev == 'ERROR': high += 1
                    else: medium += 1
                SAST_GAUGE.labels(severity='HIGH').set(high)
                SAST_GAUGE.labels(severity='MEDIUM').set(medium)
    except Exception:
        pass

def watch_docker_logs():
    """Infinite loop that reads Juice Shop logs"""
    client = docker.from_env()
    print(f"üîå Connected to Docker. Waiting for container '{JUICE_CONTAINER_NAME}'...")

    while True:
        try:
            container = client.containers.get(JUICE_CONTAINER_NAME)
            print(f"‚úÖ Attached to {JUICE_CONTAINER_NAME} logs.")
            
            # stream=True makes this a blocking loop that runs forever
            for line in container.logs(stream=True, tail=0, follow=True):
                log_line = line.decode('utf-8', errors='ignore')
                
                # --- DATADOG IAST DETECTION LOGIC ---
                if "dd-trace" in log_line and "Vulnerability detected" in log_line:
                    IAST_DETECTIONS.inc()
                    print(f"üö® IAST HIT: {log_line[:50]}...")

                # --- AIKIDO RASP DETECTION LOGIC ---
                if "Aikido" in log_line or "@aikidosec" in log_line:
                    if "SecurityException" in log_line or "Blocked" in log_line or "Attack detected" in log_line:
                        RASP_DETECTIONS.inc()
                        if "Blocked" in log_line:
                            RASP_BLOCKS.inc()
                            print(f"üõ°Ô∏è RASP BLOCK: {log_line[:50]}...")
                        else:
                            print(f"üëÅÔ∏è RASP DETECT: {log_line[:50]}...")
                            
        except docker.errors.NotFound:
            time.sleep(5)
        except Exception as e:
            print(f"‚ùå Docker error: {e}. Retrying...")
            time.sleep(5)

def main():
    print("üöÄ Thesis Log Telemetry Exporter Running on :9999")
    start_http_server(9999)
    update_sast_metrics()
    
    # Thread for scenario file watcher
    t = threading.Thread(target=lambda: [update_scenario_metrics() or time.sleep(2) for _ in iter(int, 1)])
    t.daemon = True
    t.start()
    
    # Main thread blocks on Docker logs
    watch_docker_logs()

if __name__ == '__main__':
    main()