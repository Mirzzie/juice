name: DevSecOps Pipeline - IAST vs RASP Comparison (Dual Scenario)

on:
  push:
    branches: [main, dev-test]
  pull_request:
    branches: [main, dev-test]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: "Skip Ansible configuration"
        required: false
        type: boolean
        default: false
      run_scenario:
        description: "Which scenario to run"
        required: false
        type: choice
        options:
          - both
          - iast-only
          - iast-rasp
        default: both

env:
  EC2_INSTANCE_IP: ${{ secrets.EC2_INSTANCE_IP }}
  SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
  EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
  ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}

jobs:
  # =========================================================================
  # JOB 1: SAST - Semgrep (runs once, independent of scenarios)
  # =========================================================================
  sast-semgrep:
    name: üîç SAST - Semgrep
    runs-on: ubuntu-latest
    container:
      image: semgrep/semgrep
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run Semgrep Scan
        run: |
          semgrep scan --config=auto --json --output=semgrep-results.json || true
          semgrep scan --config=auto --sarif --output=semgrep-results.sarif || true
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

      - name: Validate and Format Semgrep JSON
        run: |
          if command -v jq &> /dev/null; then
            jq '.' semgrep-results.json > semgrep-results-formatted.json || cp semgrep-results.json semgrep-results-formatted.json
            mv semgrep-results-formatted.json semgrep-results.json
          fi

          echo "üìä Semgrep Results Summary:"
          if command -v jq &> /dev/null; then
            echo "Total findings: $(jq '.results | length' semgrep-results.json)"
            echo "By severity:"
            jq -r '.results | group_by(.extra.severity) | map({severity: .[0].extra.severity, count: length}) | .[]' semgrep-results.json || true
          fi

      - name: Upload to Semgrep Dashboard
        if: always()
        run: semgrep ci
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

      - name: Upload SARIF to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep-results.sarif
          category: semgrep
        continue-on-error: true

      - name: Upload Semgrep Results to EC2
        if: always()
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

          scp -i ~/.ssh/id_rsa semgrep-results.json \
            ubuntu@${{ env.EC2_INSTANCE_IP }}:/opt/security-metrics/data/semgrep-results.json || echo "‚ö†Ô∏è  Could not upload Semgrep results"

      - name: Upload Semgrep Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: |
            semgrep-results.json
            semgrep-results.sarif

  # =========================================================================
  # JOB 2: Prerequisites Check
  # =========================================================================
  check-prerequisites:
    name: ‚úÖ Verify Prerequisites
    runs-on: ubuntu-latest
    needs: sast-semgrep
    outputs:
      can_proceed: ${{ steps.check.outputs.can_proceed }}
    steps:
      - name: Check Required Secrets
        id: check
        run: |
          MISSING_SECRETS=()
          if [ -z "${{ secrets.EC2_INSTANCE_IP }}" ]; then
            MISSING_SECRETS+=("EC2_INSTANCE_IP")
          fi
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS+=("EC2_SSH_PRIVATE_KEY")
          fi
          if [ -z "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" ]; then
            MISSING_SECRETS+=("ANSIBLE_VAULT_PASSWORD")
          fi
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "::error::Missing secrets: ${MISSING_SECRETS[*]}"
            echo "can_proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ All secrets configured"
          echo "can_proceed=true" >> $GITHUB_OUTPUT

  # =========================================================================
  # JOB 3: Configure Infrastructure (runs once)
  # =========================================================================
  configure-instance:
    name: ‚öôÔ∏è Configure Infrastructure (Ansible)
    runs-on: ubuntu-latest
    needs: check-prerequisites
    if: |
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      github.event.inputs.skip_ansible != 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: pip install ansible boto3 botocore

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Wait for SSH
        run: |
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
               -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} \
               "echo 'SSH ready'" 2>/dev/null; then
              echo "‚úÖ SSH ready"
              exit 0
            fi
            echo "Attempt $i/30..."
            sleep 10
          done
          exit 1

      - name: Create Ansible Inventory
        run: |
          mkdir -p ansible
          cat > ansible/inventory.ini <<EOF
          [juiceshop]
          ${{ env.EC2_INSTANCE_IP }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no'
          EOF

      - name: Create Vault Password
        run: |
          cd ansible
          echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > .vault_pass
          chmod 600 .vault_pass

      - name: Run Ansible Playbook
        run: |
          cd ansible
          ansible-playbook -i inventory.ini playbook.yml --vault-password-file .vault_pass -v

      - name: Clean Up Vault
        if: always()
        run: rm -f ansible/.vault_pass

      - name: Verify Configuration
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ubuntu@${{ env.EC2_INSTANCE_IP }} << 'VERIFY'
            echo "=== Service Status Verification ==="
            echo "Prometheus: $(systemctl is-active prometheus)"
            echo "Grafana: $(systemctl is-active grafana-server)"
            echo "Metrics Exporter: $(systemctl is-active security-metrics-exporter)"
            echo "DataDog Agent: $(systemctl is-active datadog-agent)"
            
            sleep 5
            
            echo ""
            echo "=== Health Checks ==="
            curl -s http://localhost:9090/-/healthy && echo "‚úÖ Prometheus healthy" || echo "‚ö†Ô∏è  Prometheus not ready"
            curl -s http://localhost:3001/api/health && echo "‚úÖ Grafana healthy" || echo "‚ö†Ô∏è  Grafana not ready"
            curl -s http://localhost:9999/metrics | head -5 && echo "‚úÖ Metrics exporter running" || echo "‚ö†Ô∏è  Metrics exporter not ready"
          VERIFY

  # =========================================================================
  # JOB 4: SCENARIO 1 - IAST Only (DataDog IAST ON, Aikido RASP OFF)
  # =========================================================================
  scenario1-iast-only:
    name: üî¨ Scenario 1 - IAST Only (Detection)
    runs-on: ubuntu-latest
    needs: [check-prerequisites, configure-instance]
    if: |
      always() &&
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      (needs.configure-instance.result == 'success' || needs.configure-instance.result == 'skipped') &&
      (github.event.inputs.run_scenario == 'both' || github.event.inputs.run_scenario == 'iast-only' || github.event.inputs.run_scenario == '')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

      - name: Deploy Application - IAST Only Configuration
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'DEPLOY'
            set -e
            cd /opt/juice-shop
            
            echo "üî¨ SCENARIO 1: DataDog IAST ON, Aikido RASP OFF"
            echo "=============================================="
            
            # Update metrics to indicate scenario 1
            cat > /opt/security-metrics/data/manual_metrics.json <<EOF
            {
              "scan_phase": 0,
              "scenario": "iast-only",
              "scenario_id": 1,
              "response_times": {
                "datadog_iast": 0,
                "aikido_rasp": 0
              }
            }
          EOF
            
            # Stop existing containers
            docker compose down 2>/dev/null || true
            docker system prune -f
            
            # Modify docker-compose.yml to DISABLE Aikido
            cat > docker-compose.yml <<'COMPOSE'
          services:
            juice-shop:
              build: .
              image: juice-shop-secure:iast-only
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                
                # DataDog IAST - ENABLED
                DD_ENV: dev
                DD_SERVICE: juice-shop-iast-only
                DD_VERSION: scenario1
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                DD_PROFILING_ENABLED: "true"
                DD_RUNTIME_METRICS_ENABLED: "true"
                DD_APPSEC_ENABLED: "true"
                DD_IAST_ENABLED: "true"
                
                # Aikido RASP - DISABLED
                AIKIDO_BLOCK: "false"
                AIKIDO_FEATURE_COLLECT_API_SCHEMA: "false"
                
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          COMPOSE
            
            echo "üì¶ Building image for IAST-only scenario..."
            docker compose build --no-cache
            
            echo "‚ñ∂Ô∏è  Starting application..."
            docker compose up -d
            
            echo "‚è≥ Waiting for application (60s)..."
            sleep 60
            
            if docker ps | grep -q juice-shop; then
              echo "‚úÖ Application running"
              curl -f http://localhost:3000 && echo "‚úÖ Health check passed" || echo "‚ö†Ô∏è  Check manually"
            else
              echo "‚ùå Deployment failed"
              exit 1
            fi
          DEPLOY

      - name: Run Complete DAST Testing - Scenario 1
        run: |
          echo "üß™ Running DAST tests for Scenario 1 (IAST Only)"

          # Phase 1: Baseline Scan
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE1'
            jq '.scan_phase = 1 | .scenario = "iast-only"' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE1

          # Run ZAP Baseline
          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario1-baseline.json -r scenario1-baseline.html || true

          # Upload results
          scp -i ~/.ssh/id_rsa scenario1-baseline.json \
            ubuntu@${{ env.EC2_INSTANCE_IP }}:/opt/security-metrics/zap-results/scenario1_baseline.json

          # Phase 2: Full Scan
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE2'
            jq '.scan_phase = 2' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE2

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario1-full.json -r scenario1-full.html -m 5 -T 180 || true

          scp -i ~/.ssh/id_rsa scenario1-full.json \
            ubuntu@${{ env.EC2_INSTANCE_IP }}:/opt/security-metrics/zap-results/scenario1_full.json

          # Phase 3: Targeted Attacks
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE3'
            jq '.scan_phase = 3' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE3

          # Execute attacks
          for i in {1..20}; do
            # XSS
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=<script>alert(1)</script>" >/dev/null || true
            # SQLi
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=' OR '1'='1" >/dev/null || true
            # Path traversal
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/ftp/../../../etc/passwd" >/dev/null || true
            sleep 2
          done

          echo "‚úÖ Scenario 1 testing complete"
          sleep 60  # Allow metrics to propagate

      - name: Collect Scenario 1 Metrics
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'COLLECT'
            echo "üìä SCENARIO 1 METRICS"
            echo "===================="
            curl -s http://localhost:9999/metrics | grep 'scenario="iast-only"' || echo "Scenario 1 metrics"
            curl -s http://localhost:9999/metrics | grep 'security_detections_total.*datadog_iast' || echo "IAST detections"
            curl -s http://localhost:9999/metrics | grep 'security_blocks_total.*aikido_rasp' || echo "No RASP blocks expected"
          COLLECT

      - name: Upload Scenario 1 Results
        uses: actions/upload-artifact@v4
        with:
          name: scenario1-iast-only-results
          path: |
            scenario1-*.json
            scenario1-*.html

  # =========================================================================
  # JOB 5: SCENARIO 2 - IAST + RASP (DataDog IAST ON, Aikido RASP ON)
  # =========================================================================
  scenario2-iast-rasp:
    name: üõ°Ô∏è Scenario 2 - IAST + RASP (Detection + Blocking)
    runs-on: ubuntu-latest
    needs: [check-prerequisites, configure-instance, scenario1-iast-only]
    if: |
      always() &&
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      (needs.scenario1-iast-only.result == 'success' || needs.scenario1-iast-only.result == 'skipped') &&
      (github.event.inputs.run_scenario == 'both' || github.event.inputs.run_scenario == 'iast-rasp' || github.event.inputs.run_scenario == '')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

      - name: Deploy Application - IAST + RASP Configuration
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'DEPLOY'
            set -e
            cd /opt/juice-shop
            
            echo "üõ°Ô∏è SCENARIO 2: DataDog IAST ON, Aikido RASP ON"
            echo "=============================================="
            
            # Update metrics to indicate scenario 2
            cat > /opt/security-metrics/data/manual_metrics.json <<EOF
            {
              "scan_phase": 0,
              "scenario": "iast-rasp",
              "scenario_id": 2,
              "response_times": {
                "datadog_iast": 0,
                "aikido_rasp": 0
              }
            }
          EOF
            
            # Stop existing containers
            docker compose down 2>/dev/null || true
            docker system prune -f
            
            # Modify docker-compose.yml to ENABLE Aikido
            cat > docker-compose.yml <<'COMPOSE'
          services:
            juice-shop:
              build: .
              image: juice-shop-secure:iast-rasp
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                
                # DataDog IAST - ENABLED
                DD_ENV: dev
                DD_SERVICE: juice-shop-iast-rasp
                DD_VERSION: scenario2
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                DD_PROFILING_ENABLED: "true"
                DD_RUNTIME_METRICS_ENABLED: "true"
                DD_APPSEC_ENABLED: "true"
                DD_IAST_ENABLED: "true"
                
                # Aikido RASP - ENABLED WITH BLOCKING
                AIKIDO_TOKEN: ${AIKIDO_TOKEN}
                AIKIDO_BLOCK: "true"
                AIKIDO_DEBUG: "true"
                
              env_file:
                - .env
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          COMPOSE
            
            echo "üì¶ Building image for IAST+RASP scenario..."
            docker compose build --no-cache
            
            echo "‚ñ∂Ô∏è  Starting application..."
            docker compose up -d
            
            echo "‚è≥ Waiting for application (60s)..."
            sleep 60
            
            if docker ps | grep -q juice-shop; then
              echo "‚úÖ Application running"
              
              # Verify RASP is active
              docker logs juice-shop 2>&1 | grep -i "aikido" | tail -10 || echo "Check RASP logs"
              
              curl -f http://localhost:3000 && echo "‚úÖ Health check passed" || echo "‚ö†Ô∏è  Check manually"
            else
              echo "‚ùå Deployment failed"
              exit 1
            fi
          DEPLOY

      - name: Run Complete DAST Testing - Scenario 2
        run: |
          echo "üß™ Running DAST tests for Scenario 2 (IAST + RASP)"

          # Phase 1: Baseline Scan
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE1'
            jq '.scan_phase = 1 | .scenario = "iast-rasp"' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE1

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2-baseline.json -r scenario2-baseline.html || true

          scp -i ~/.ssh/id_rsa scenario2-baseline.json \
            ubuntu@${{ env.EC2_INSTANCE_IP }}:/opt/security-metrics/zap-results/scenario2_baseline.json

          # Phase 2: Full Scan
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE2'
            jq '.scan_phase = 2' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE2

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2-full.json -r scenario2-full.html -m 5 -T 180 || true

          scp -i ~/.ssh/id_rsa scenario2-full.json \
            ubuntu@${{ env.EC2_INSTANCE_IP }}:/opt/security-metrics/zap-results/scenario2_full.json

          # Phase 3: Targeted Attacks (should see RASP blocking)
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'PHASE3'
            jq '.scan_phase = 3' /opt/security-metrics/data/manual_metrics.json > /tmp/m.json
            mv /tmp/m.json /opt/security-metrics/data/manual_metrics.json
          PHASE3

          echo "üéØ Executing attacks - RASP should block many of these"
          for i in {1..20}; do
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=<script>alert(1)</script>" >/dev/null || echo "Blocked by RASP"
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=' OR '1'='1" >/dev/null || echo "Blocked by RASP"
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/ftp/../../../etc/passwd" >/dev/null || echo "Blocked by RASP"
            sleep 2
          done

          echo "‚úÖ Scenario 2 testing complete - Check for RASP blocks!"
          sleep 60

      - name: Collect Scenario 2 Metrics
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'COLLECT'
            echo "üìä SCENARIO 2 METRICS"
            echo "===================="
            curl -s http://localhost:9999/metrics | grep 'scenario="iast-rasp"' || echo "Scenario 2 metrics"
            curl -s http://localhost:9999/metrics | grep 'security_detections_total.*datadog_iast' || echo "IAST detections"
            curl -s http://localhost:9999/metrics | grep 'security_detections_total.*aikido_rasp' || echo "RASP detections"
            curl -s http://localhost:9999/metrics | grep 'security_blocks_total.*aikido_rasp' || echo "RASP blocks"
            
            echo ""
            echo "üõ°Ô∏è RASP Blocking Evidence:"
            docker logs juice-shop 2>&1 | grep -i "blocked\|aikido" | tail -20
          COLLECT

      - name: Upload Scenario 2 Results
        uses: actions/upload-artifact@v4
        with:
          name: scenario2-iast-rasp-results
          path: |
            scenario2-*.json
            scenario2-*.html

  # =========================================================================
  # JOB 6: Generate Comparative Analysis Report
  # =========================================================================
  generate-comparison-report:
    name: üìä Generate Comparison Report
    runs-on: ubuntu-latest
    needs: [scenario1-iast-only, scenario2-iast-rasp]
    if: always()
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true

      - name: Query Prometheus for Comparative Metrics
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} << 'QUERY' > comparison-metrics.txt
            echo "=========================================="
            echo "COMPARATIVE ANALYSIS: IAST vs IAST+RASP"
            echo "=========================================="
            
            echo ""
            echo "=== SAST (Semgrep) - Baseline ==="
            curl -s 'http://localhost:9090/api/v1/query?query=sum(sast_vulnerabilities_found{rule_id="total"})' | jq -r '.data.result[0].value[1] // "0"' | xargs echo "Total vulnerabilities:"
            
            echo ""
            echo "=== SCENARIO 1: IAST ONLY ==="
            echo "DAST Vulnerabilities (Baseline):"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(dast_vulnerabilities_found{scan_type="baseline",scenario="iast-only"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "DAST Vulnerabilities (Full):"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(dast_vulnerabilities_found{scan_type="full",scenario="iast-only"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "IAST Detections:"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(security_detections_total{tool="datadog_iast",scenario="iast-only"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "RASP Blocks:"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(security_blocks_total{tool="aikido_rasp",scenario="iast-only"})' | jq -r '.data.result[0].value[1] // "0 (RASP disabled)"'
            
            echo ""
            echo "=== SCENARIO 2: IAST + RASP ==="
            echo "DAST Vulnerabilities (Baseline):"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(dast_vulnerabilities_found{scan_type="baseline",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "DAST Vulnerabilities (Full):"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(dast_vulnerabilities_found{scan_type="full",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "IAST Detections:"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(security_detections_total{tool="datadog_iast",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "RASP Detections:"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(security_detections_total{tool="aikido_rasp",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo "RASP Blocks:"
            curl -s 'http://localhost:9090/api/v1/query?query=sum(security_blocks_total{tool="aikido_rasp",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"'
            
            echo ""
            echo "=== RASP EFFECTIVENESS ==="
            RASP_DETECTIONS=$(curl -s 'http://localhost:9090/api/v1/query?query=sum(security_detections_total{tool="aikido_rasp",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"')
            RASP_BLOCKS=$(curl -s 'http://localhost:9090/api/v1/query?query=sum(security_blocks_total{tool="aikido_rasp",scenario="iast-rasp"})' | jq -r '.data.result[0].value[1] // "0"')
            
            if [ "$RASP_DETECTIONS" != "0" ]; then
              BLOCK_RATE=$(echo "scale=2; ($RASP_BLOCKS / $RASP_DETECTIONS) * 100" | bc)
              echo "Block Rate: ${BLOCK_RATE}%"
            else
              echo "Block Rate: N/A (no detections)"
            fi
          QUERY

          cat comparison-metrics.txt

      - name: Generate Summary Report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # üîí IAST vs RASP Comparison Analysis

          **Pipeline Run:** #${{ github.run_number }}  
          **Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
          **Instance:** ${{ env.EC2_INSTANCE_IP }}

          ---

          ## üìä Two-Scenario Testing Complete

          | Scenario | Configuration | Status |
          |----------|--------------|--------|
          | **Scenario 1** | IAST Only (Detection) | ${{ needs.scenario1-iast-only.result }} |
          | **Scenario 2** | IAST + RASP (Detection + Blocking) | ${{ needs.scenario2-iast-rasp.result }} |

          ---

          ## üîç Key Findings

          ### Scenario 1: IAST Only
          - ‚úÖ **Detection**: DataDog IAST active
          - ‚ùå **Blocking**: No blocking capability
          - üìä **Result**: Attacks detected but NOT prevented

          ### Scenario 2: IAST + RASP
          - ‚úÖ **Detection**: DataDog IAST + Aikido RASP
          - ‚úÖ **Blocking**: Aikido RASP actively blocking
          - üìä **Result**: Attacks detected AND prevented (~80% block rate expected)

          ---

          ## üìà Access Live Dashboards

          ### Grafana Dashboard
          **URL:** http://${{ env.EC2_INSTANCE_IP }}:3001  
          **Login:** admin / admin  
          **Dashboard:** "DevSecOps Security Tools Comparison"

          View real-time metrics including:
          - Side-by-side scenario comparison
          - IAST detection rates
          - RASP blocking effectiveness
          - Attack type distribution

          ### Prometheus
          **URL:** http://${{ env.EC2_INSTANCE_IP }}:9090

          **Comparative Queries:**
          ```promql
          # Compare IAST detections between scenarios
          sum by (scenario) (security_detections_total{tool="datadog_iast"})

          # RASP blocking (Scenario 2 only)
          sum(security_blocks_total{tool="aikido_rasp",scenario="iast-rasp"})

          # RASP block rate
          (sum(security_blocks_total{tool="aikido_rasp",scenario="iast-rasp"}) / 
           sum(security_detections_total{tool="aikido_rasp",scenario="iast-rasp"})) * 100

          # Compare DAST findings between scenarios
          sum by (scenario, scan_type) (dast_vulnerabilities_found)
          ```

          ---

          ## üéØ Thesis Validation

          ### Hypothesis
          **RASP provides superior protection by both detecting AND blocking attacks, while IAST only detects.**

          ### Expected Results
          | Metric | IAST Only | IAST + RASP | Difference |
          |--------|-----------|-------------|------------|
          | **Attacks Detected** | ~100% | ~100% | Same detection |
          | **Attacks Blocked** | 0% | ~80% | **RASP advantage** |
          | **Protection Level** | Detection only | Detection + Prevention | **RASP superior** |

          ### Key Takeaway
          Both IAST and RASP detect vulnerabilities, but **only RASP actively prevents exploitation** by blocking malicious requests in real-time.

          ---

          ## üîß SSH Commands for Analysis

          ```bash
          ssh -i your-key.pem ubuntu@${{ env.EC2_INSTANCE_IP }}

          # View all metrics
          curl http://localhost:9999/metrics

          # Scenario 1 metrics (IAST only)
          curl http://localhost:9999/metrics | grep 'scenario="iast-only"'

          # Scenario 2 metrics (IAST + RASP)
          curl http://localhost:9999/metrics | grep 'scenario="iast-rasp"'

          # RASP blocking evidence
          docker logs juice-shop 2>&1 | grep -i "blocked\|aikido"

          # Check service status
          systemctl status security-metrics-exporter
          systemctl status prometheus
          systemctl status grafana-server
          ```

          ---

          ## üìã Next Steps for Thesis

          1. **Screenshot Grafana dashboards** showing side-by-side comparison
          2. **Export Prometheus metrics** for quantitative analysis
          3. **Document RASP block rate** from real attack simulation
          4. **Compare performance overhead** between scenarios
          5. **Analyze false positive rates** for both tools

          EOF

      - name: Upload Final Comparison Report
        uses: actions/upload-artifact@v4
        with:
          name: comparison-analysis-report
          path: |
            comparison-metrics.txt
