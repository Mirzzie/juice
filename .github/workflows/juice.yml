name: DevSecOps Pipeline - IAST vs RASP (OpenTelemetry Enabled)

on:
  push:
    branches: [main, dev-test]
  pull_request:
    branches: [main, dev-test]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: "Skip Ansible configuration"
        required: false
        type: boolean
        default: false
      run_scenario:
        description: "Which scenario to run"
        required: false
        type: choice
        options:
          - all
          - iast-only
          - iast-rasp-detect
          - iast-rasp-block
        default: all

env:
  EC2_INSTANCE_IP: ${{ secrets.EC2_INSTANCE_IP }}
  SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
  EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
  ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}

jobs:
  # =========================================================================
  # JOB 1: SAST - Semgrep
  # =========================================================================
  sast-semgrep:
    name: üîç SAST - Semgrep
    runs-on: ubuntu-latest
    container:
      image: semgrep/semgrep
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run Semgrep Scan
        run: |
          semgrep scan --config=auto --json --output=semgrep-results.json || true
          semgrep scan --config=auto --sarif --output=semgrep-results.sarif || true
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

      - name: Upload to Semgrep Dashboard
        if: always()
        run: semgrep ci
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

      - name: Upload Semgrep Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: |
            semgrep-results.json
            semgrep-results.sarif

  # =========================================================================
  # JOB 2: Prerequisites Check
  # =========================================================================
  check-prerequisites:
    name: ‚úÖ Verify Prerequisites
    runs-on: ubuntu-latest
    needs: sast-semgrep
    outputs:
      can_proceed: ${{ steps.check.outputs.can_proceed }}
    steps:
      - name: Check Required Secrets
        id: check
        run: |
          MISSING_SECRETS=()
          if [ -z "${{ secrets.EC2_INSTANCE_IP }}" ]; then
            MISSING_SECRETS+=("EC2_INSTANCE_IP")
          fi
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS+=("EC2_SSH_PRIVATE_KEY")
          fi
          if [ -z "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" ]; then
            MISSING_SECRETS+=("ANSIBLE_VAULT_PASSWORD")
          fi
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "::error::Missing secrets: ${MISSING_SECRETS[*]}"
            echo "can_proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ All secrets configured"
          echo "can_proceed=true" >> $GITHUB_OUTPUT

  # =========================================================================
  # JOB 3: Configure Infrastructure with OpenTelemetry
  # =========================================================================
  configure-instance:
    name: ‚öôÔ∏è Configure Infrastructure (OTel Enabled)
    runs-on: ubuntu-latest
    needs: check-prerequisites
    if: |
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      github.event.inputs.skip_ansible != 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: pip install ansible boto3 botocore

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Wait for SSH
        run: |
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
               -i ~/.ssh/id_rsa ubuntu@${{ env.EC2_INSTANCE_IP }} \
               "echo 'SSH ready'" 2>/dev/null; then
              echo "‚úÖ SSH ready"
              exit 0
            fi
            echo "Attempt $i/30..."
            sleep 10
          done
          exit 1

      - name: Create Ansible Inventory
        run: |
          mkdir -p ansible
          cat > ansible/inventory.ini <<EOF
          [juiceshop]
          ${{ env.EC2_INSTANCE_IP }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no'
          EOF

      - name: Create Vault Password
        run: |
          cd ansible
          echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > .vault_pass
          chmod 600 .vault_pass

      - name: Run Ansible Playbook (OpenTelemetry Setup)
        run: |
          cd ansible
          ansible-playbook -i inventory.ini playbook.yml --vault-password-file .vault_pass -v

      - name: Clean Up Vault
        if: always()
        run: rm -f ansible/.vault_pass

  # =========================================================================
  # JOB 4: SCENARIO 1 - IAST Only (Detection, No RASP)
  # =========================================================================
  scenario1-iast-only:
    name: üî¨ Scenario 1 - IAST Only (No RASP)
    runs-on: ubuntu-latest
    needs: [check-prerequisites, configure-instance]
    if: |
      always() &&
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      (needs.configure-instance.result == 'success' || needs.configure-instance.result == 'skipped') &&
      (github.event.inputs.run_scenario == 'all' || github.event.inputs.run_scenario == 'iast-only' || github.event.inputs.run_scenario == '')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH with Keepalive
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

          cat >> ~/.ssh/config <<EOF
          Host ec2
            HostName ${{ env.EC2_INSTANCE_IP }}
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            ServerAliveInterval 30
            ServerAliveCountMax 120
            TCPKeepAlive yes
          EOF

      - name: Deploy Application - IAST Only (Build on EC2)
        run: |
          ssh ec2 << 'DEPLOY'
            set -e
            cd /opt/juice-shop
            
            echo "üî¨ SCENARIO 1: DataDog IAST ON, Aikido RASP OFF"
            echo "=============================================="
            
            # Update scenario tracking
            cat > /opt/security-metrics/data/scenario_info.json <<EOF
            {
              "current_scenario": "iast-only",
              "scenario_id": 1,
              "scenario_name": "IAST Only - Detection Only",
              "rasp_enabled": false,
              "rasp_blocking": false,
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            }
          EOF
            
            # Stop existing containers
            docker compose down 2>/dev/null || true
            docker system prune -f
            
            # Create docker-compose.yml with OpenTelemetry enabled
            cat > docker-compose.yml <<'COMPOSE'
          services:
            juice-shop:
              build: .
              image: juice-shop-secure:iast-only
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                
                # DataDog IAST Configuration with OpenTelemetry
                DD_ENV: dev
                DD_SERVICE: juice-shop-iast-only
                DD_VERSION: scenario1
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                
                # DataDog AppSec & IAST
                DD_APPSEC_ENABLED: "true"
                DD_IAST_ENABLED: "true"
                DD_APPSEC_REPORTING_ENABLED: "true"
                DD_APPSEC_SCA_ENABLED: "true"
                
                # DataDog OpenTelemetry Export
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_GRPC_ENDPOINT: "0.0.0.0:4317"
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_HTTP_ENDPOINT: "0.0.0.0:4318"
                DD_OTLP_CONFIG_TRACES_ENABLED: "true"
                DD_OTLP_CONFIG_METRICS_ENABLED: "true"
                DD_OTLP_CONFIG_LOGS_ENABLED: "true"
                
                # Aikido RASP - DISABLED for Scenario 1
                AIKIDO_BLOCK: "false"
                AIKIDO_FEATURE_COLLECT_METRICS: "false"
                
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          COMPOSE
            
            echo "üì¶ Building image for Scenario 1..."
            nohup docker compose build --no-cache > /tmp/build-scenario1.log 2>&1 &
            BUILD_PID=$!
            
            tail -f /tmp/build-scenario1.log &
            TAIL_PID=$!
            
            if wait $BUILD_PID; then
              kill $TAIL_PID 2>/dev/null || true
              echo "‚úÖ Build completed"
            else
              kill $TAIL_PID 2>/dev/null || true
              echo "‚ùå Build failed!"
              tail -100 /tmp/build-scenario1.log
              exit 1
            fi
            
            echo "‚ñ∂Ô∏è  Starting application..."
            docker compose up -d
            
            echo "‚è≥ Waiting 60s for application..."
            sleep 60
            
            if docker ps | grep -q juice-shop; then
              echo "‚úÖ Application running"
              docker logs juice-shop 2>&1 | grep -i "listening\|started\|ready" | tail -5
              curl -f http://localhost:3000 && echo "‚úÖ Health check passed" || echo "‚ö†Ô∏è  Manual verification needed"
            else
              echo "‚ùå Deployment failed"
              docker compose logs --tail=50
              exit 1
            fi
          DEPLOY

      - name: Run DAST Testing - Scenario 1
        run: |
          echo "üß™ Running DAST tests for Scenario 1 (IAST Only)"

          # Baseline Scan
          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario1-baseline.json -r scenario1-baseline.html || true

          # Full Scan
          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario1-full.json -r scenario1-full.html -m 5 -T 180 || true

          # Targeted Attacks (All should succeed - no blocking)
          echo "üéØ Launching attacks (expecting NO blocks)..."
          for i in {1..30}; do
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=<script>alert(1)</script>" >/dev/null || true
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=' OR '1'='1" >/dev/null || true
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/user/login" \
              -X POST -H "Content-Type: application/json" \
              -d '{"email":"admin@juice-sh.op","password":"admin123"}' >/dev/null || true
            sleep 2
          done

          echo "‚úÖ Scenario 1 testing complete - IAST detections expected, 0 blocks expected"

      - name: Upload Scenario 1 Results
        uses: actions/upload-artifact@v4
        with:
          name: scenario1-iast-only-results
          path: |
            scenario1-*.json
            scenario1-*.html

  # =========================================================================
  # JOB 5: SCENARIO 2A - IAST + RASP (Detection Only Mode)
  # =========================================================================
  scenario2a-iast-rasp-detect:
    name: üõ°Ô∏è Scenario 2A - IAST + RASP (Detection Only)
    runs-on: ubuntu-latest
    needs: [check-prerequisites, configure-instance, scenario1-iast-only]
    if: |
      always() &&
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      (needs.scenario1-iast-only.result == 'success' || needs.scenario1-iast-only.result == 'skipped') &&
      (github.event.inputs.run_scenario == 'all' || github.event.inputs.run_scenario == 'iast-rasp-detect' || github.event.inputs.run_scenario == '')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH with Keepalive
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

          cat >> ~/.ssh/config <<EOF
          Host ec2
            HostName ${{ env.EC2_INSTANCE_IP }}
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            ServerAliveInterval 30
            ServerAliveCountMax 120
            TCPKeepAlive yes
          EOF

      - name: Deploy Application - IAST + RASP Detection Mode
        run: |
          ssh ec2 << 'DEPLOY'
            set -e
            cd /opt/juice-shop
            
            echo "üõ°Ô∏è SCENARIO 2A: DataDog IAST ON, Aikido RASP ON (DETECTION ONLY)"
            echo "================================================================"
            
            # Update scenario tracking
            cat > /opt/security-metrics/data/scenario_info.json <<EOF
            {
              "current_scenario": "iast-rasp-detect",
              "scenario_id": 2,
              "scenario_name": "IAST + RASP - Detection Only Mode",
              "rasp_enabled": true,
              "rasp_blocking": false,
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            }
          EOF
            
            docker compose down 2>/dev/null || true
            docker system prune -f
            
            # Create docker-compose.yml with RASP in detection-only mode
            cat > docker-compose.yml <<'COMPOSE'
          services:
            juice-shop:
              build: .
              image: juice-shop-secure:iast-rasp-detect
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                
                # DataDog IAST with OpenTelemetry
                DD_ENV: dev
                DD_SERVICE: juice-shop-iast-rasp-detect
                DD_VERSION: scenario2a
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                DD_APPSEC_ENABLED: "true"
                DD_IAST_ENABLED: "true"
                
                # DataDog OpenTelemetry Export
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_GRPC_ENDPOINT: "0.0.0.0:4317"
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_HTTP_ENDPOINT: "0.0.0.0:4318"
                DD_OTLP_CONFIG_TRACES_ENABLED: "true"
                DD_OTLP_CONFIG_METRICS_ENABLED: "true"
                DD_OTLP_CONFIG_LOGS_ENABLED: "true"
                
                # Aikido RASP - DETECTION ONLY (NO BLOCKING)
                AIKIDO_TOKEN: ${AIKIDO_TOKEN}
                AIKIDO_BLOCK: "false"
                AIKIDO_DEBUG: "true"
                AIKIDO_FEATURE_COLLECT_METRICS: "true"
                AIKIDO_REPORTING_ENABLED: "true"
                
                # OpenTelemetry Export for Aikido
                OTEL_EXPORTER_OTLP_ENDPOINT: "http://172.17.0.1:4317"
                OTEL_EXPORTER_OTLP_PROTOCOL: "grpc"
                OTEL_SERVICE_NAME: "juice-shop-rasp-detect"
                
              env_file:
                - .env
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          COMPOSE
            
            echo "üì¶ Building image for Scenario 2A (RASP Detection Only)..."
            nohup docker compose build --no-cache > /tmp/build-scenario2a.log 2>&1 &
            BUILD_PID=$!
            
            tail -f /tmp/build-scenario2a.log &
            TAIL_PID=$!
            
            if wait $BUILD_PID; then
              kill $TAIL_PID 2>/dev/null || true
              echo "‚úÖ Build completed"
            else
              kill $TAIL_PID 2>/dev/null || true
              echo "‚ùå Build failed!"
              tail -100 /tmp/build-scenario2a.log
              exit 1
            fi
            
            echo "‚ñ∂Ô∏è  Starting application..."
            docker compose up -d
            
            echo "‚è≥ Waiting 60s for application..."
            sleep 60
            
            if docker ps | grep -q juice-shop; then
              echo "‚úÖ Application running"
              docker logs juice-shop 2>&1 | grep -i "aikido\|firewall" | tail -10
              curl -f http://localhost:3000 && echo "‚úÖ Health check passed" || echo "‚ö†Ô∏è  Manual verification needed"
            else
              echo "‚ùå Deployment failed"
              docker compose logs --tail=50
              exit 1
            fi
          DEPLOY

      - name: Run DAST Testing - Scenario 2A (Detection Only)
        run: |
          echo "üß™ Running DAST tests for Scenario 2A (RASP Detection Only)"

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2a-baseline.json -r scenario2a-baseline.html || true

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2a-full.json -r scenario2a-full.html -m 5 -T 180 || true

          echo "üéØ Launching attacks (expecting DETECTION but NO BLOCKING)..."
          for i in {1..30}; do
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=<script>alert(1)</script>" >/dev/null || true
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=' OR '1'='1" >/dev/null || true
            curl -s "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/user/login" \
              -X POST -H "Content-Type: application/json" \
              -d '{"email":"admin@juice-sh.op","password":"admin123"}' >/dev/null || true
            sleep 2
          done

          echo "‚úÖ Scenario 2A complete - RASP detections expected, 0 blocks expected"

      - name: Upload Scenario 2A Results
        uses: actions/upload-artifact@v4
        with:
          name: scenario2a-iast-rasp-detect-results
          path: |
            scenario2a-*.json
            scenario2a-*.html

  # =========================================================================
  # JOB 6: SCENARIO 2B - IAST + RASP (Blocking Mode)
  # =========================================================================
  scenario2b-iast-rasp-block:
    name: üö´ Scenario 2B - IAST + RASP (Blocking Mode)
    runs-on: ubuntu-latest
    needs: [check-prerequisites, configure-instance, scenario2a-iast-rasp-detect]
    if: |
      always() &&
      needs.check-prerequisites.outputs.can_proceed == 'true' &&
      (needs.scenario2a-iast-rasp-detect.result == 'success' || needs.scenario2a-iast-rasp-detect.result == 'skipped') &&
      (github.event.inputs.run_scenario == 'all' || github.event.inputs.run_scenario == 'iast-rasp-block' || github.event.inputs.run_scenario == '')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH with Keepalive
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_INSTANCE_IP }} >> ~/.ssh/known_hosts

          cat >> ~/.ssh/config <<EOF
          Host ec2
            HostName ${{ env.EC2_INSTANCE_IP }}
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            ServerAliveInterval 30
            ServerAliveCountMax 120
            TCPKeepAlive yes
          EOF

      - name: Deploy Application - IAST + RASP Blocking Mode
        run: |
          ssh ec2 << 'DEPLOY'
            set -e
            cd /opt/juice-shop
            
            echo "üö´ SCENARIO 2B: DataDog IAST ON, Aikido RASP ON (BLOCKING MODE)"
            echo "=============================================================="
            
            # Update scenario tracking
            cat > /opt/security-metrics/data/scenario_info.json <<EOF
            {
              "current_scenario": "iast-rasp-block",
              "scenario_id": 3,
              "scenario_name": "IAST + RASP - Blocking Mode",
              "rasp_enabled": true,
              "rasp_blocking": true,
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            }
          EOF
            
            docker compose down 2>/dev/null || true
            docker system prune -f
            
            # Create docker-compose.yml with RASP in BLOCKING mode
            cat > docker-compose.yml <<'COMPOSE'
          services:
            juice-shop:
              build: .
              image: juice-shop-secure:iast-rasp-block
              container_name: juice-shop
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
                
                # DataDog IAST with OpenTelemetry
                DD_ENV: dev
                DD_SERVICE: juice-shop-iast-rasp-block
                DD_VERSION: scenario2b
                DD_AGENT_HOST: 172.17.0.1
                DD_TRACE_AGENT_PORT: 8126
                DD_LOGS_INJECTION: "true"
                DD_TRACE_SAMPLE_RATE: "1"
                DD_APPSEC_ENABLED: "true"
                DD_IAST_ENABLED: "true"
                
                # DataDog OpenTelemetry Export
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_GRPC_ENDPOINT: "0.0.0.0:4317"
                DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_HTTP_ENDPOINT: "0.0.0.0:4318"
                DD_OTLP_CONFIG_TRACES_ENABLED: "true"
                DD_OTLP_CONFIG_METRICS_ENABLED: "true"
                DD_OTLP_CONFIG_LOGS_ENABLED: "true"
                
                # Aikido RASP - BLOCKING MODE ENABLED
                AIKIDO_TOKEN: ${AIKIDO_TOKEN}
                AIKIDO_BLOCK: "true"
                AIKIDO_DEBUG: "true"
                AIKIDO_FEATURE_COLLECT_METRICS: "true"
                AIKIDO_REPORTING_ENABLED: "true"
                
                # OpenTelemetry Export for Aikido
                OTEL_EXPORTER_OTLP_ENDPOINT: "http://172.17.0.1:4317"
                OTEL_EXPORTER_OTLP_PROTOCOL: "grpc"
                OTEL_SERVICE_NAME: "juice-shop-rasp-block"
                OTEL_METRICS_EXPORTER: "otlp"
                OTEL_TRACES_EXPORTER: "otlp"
                
              env_file:
                - .env
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          COMPOSE
            
            echo "üì¶ Building image for Scenario 2B (RASP Blocking)..."
            nohup docker compose build --no-cache > /tmp/build-scenario2b.log 2>&1 &
            BUILD_PID=$!
            
            tail -f /tmp/build-scenario2b.log &
            TAIL_PID=$!
            
            if wait $BUILD_PID; then
              kill $TAIL_PID 2>/dev/null || true
              echo "‚úÖ Build completed"
            else
              kill $TAIL_PID 2>/dev/null || true
              echo "‚ùå Build failed!"
              tail -100 /tmp/build-scenario2b.log
              exit 1
            fi
            
            echo "‚ñ∂Ô∏è  Starting application..."
            docker compose up -d
            
            echo "‚è≥ Waiting 60s for application..."
            sleep 60
            
            if docker ps | grep -q juice-shop; then
              echo "‚úÖ Application running with BLOCKING enabled"
              docker logs juice-shop 2>&1 | grep -i "aikido\|block\|firewall" | tail -15
              curl -f http://localhost:3000 && echo "‚úÖ Health check passed" || echo "‚ö†Ô∏è  Manual verification needed"
            else
              echo "‚ùå Deployment failed"
              docker compose logs --tail=50
              exit 1
            fi
          DEPLOY

      - name: Run DAST Testing - Scenario 2B (Blocking Mode)
        run: |
          echo "üß™ Running DAST tests for Scenario 2B (RASP Blocking)"

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2b-baseline.json -r scenario2b-baseline.html || true

          docker run --rm -v $(pwd):/zap/wrk:rw \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py -t http://${{ env.EC2_INSTANCE_IP }}:3000 \
            -J scenario2b-full.json -r scenario2b-full.html -m 5 -T 180 || true

          echo "üéØ Launching attacks (expecting HIGH BLOCK RATE ~80%)..."
          BLOCKED_COUNT=0
          TOTAL_ATTEMPTS=30
          
          for i in $(seq 1 $TOTAL_ATTEMPTS); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=<script>alert(1)</script>")
            if [ "$HTTP_CODE" == "403" ] || [ "$HTTP_CODE" == "418" ]; then
              BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
              echo "‚úÖ Attack $i: BLOCKED (HTTP $HTTP_CODE)"
            else
              echo "‚ö†Ô∏è  Attack $i: Passed (HTTP $HTTP_CODE)"
            fi
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              "http://${{ env.EC2_INSTANCE_IP }}:3000/rest/products/search?q=' OR '1'='1")
            if [ "$HTTP_CODE" == "403" ] || [ "$HTTP_CODE" == "418" ]; then
              BLOCKED_COUNT=$((BLOCKED_COUNT + 1))
              echo "‚úÖ Attack $i: BLOCKED (HTTP $HTTP_CODE)"
            else
              echo "‚ö†Ô∏è  Attack $i: Passed (HTTP $HTTP_CODE)"
            fi
            
            sleep 2
          done

          BLOCK_RATE=$((BLOCKED_COUNT * 100 / (TOTAL_ATTEMPTS * 2)))
          echo ""
          echo "üìä BLOCKING STATISTICS:"
          echo "   Total Attack Attempts: $((TOTAL_ATTEMPTS * 2))"
          echo "   Blocked: $BLOCKED_COUNT"
          echo "   Block Rate: ${BLOCK_RATE}%"
          echo ""
          
          if [ $BLOCK_RATE -ge 60 ]; then
            echo "‚úÖ Scenario 2B complete - RASP blocking working effectively (${BLOCK_RATE}%)"
          else
            echo "‚ö†Ô∏è  Warning: Block rate below expected (${BLOCK_RATE}% < 60%)"
          fi

      - name: Upload Scenario 2B Results
        uses: actions/upload-artifact@v4
        with:
          name: scenario2b-iast-rasp-block-results
          path: |
            scenario2b-*.json
            scenario2b-*.html

  # =========================================================================
  # JOB 7: Generate Comprehensive Comparison Report
  # =========================================================================
  generate-comparison:
    name: üìä Generate Three-Scenario Comparison
    runs-on: ubuntu-latest
    needs: [scenario1-iast-only, scenario2a-iast-rasp-detect, scenario2b-iast-rasp-block]
    if: always()
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true

      - name: Generate Comprehensive Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # üîí IAST vs RASP Three-Scenario Comparison Results

          **Pipeline Run:** #${{ github.run_number }}  
          **Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          ## Test Scenarios Executed

          | Scenario | Configuration | RASP Mode | Expected Blocks | Status |
          |----------|--------------|-----------|----------------|--------|
          | **Scenario 1** | IAST Only | N/A | 0% | ${{ needs.scenario1-iast-only.result }} |
          | **Scenario 2A** | IAST + RASP | Detection Only | 0% | ${{ needs.scenario2a-iast-rasp-detect.result }} |
          | **Scenario 2B** | IAST + RASP | Blocking Mode | ~80% | ${{ needs.scenario2b-iast-rasp-block.result }} |

          ## Key Findings Summary

          ### Scenario 1: IAST Only (Baseline)
          - ‚úÖ **Detection:** IAST active
          - ‚ùå **Blocking:** None (0%)
          - üìä **Result:** Vulnerabilities detected but NOT prevented
          - üéØ **Purpose:** Establish detection-only baseline

          ### Scenario 2A: IAST + RASP (Detection Only)
          - ‚úÖ **Detection:** IAST + RASP active
          - ‚ùå **Blocking:** Disabled (0%)
          - üìä **Result:** Enhanced detection from both tools
          - üéØ **Purpose:** Compare detection capabilities without blocking

          ### Scenario 2B: IAST + RASP (Blocking Mode)
          - ‚úÖ **Detection:** IAST + RASP active
          - ‚úÖ **Blocking:** Enabled (~80% expected)
          - üìä **Result:** Attacks detected AND actively prevented
          - üéØ **Purpose:** Demonstrate RASP protection capability

          ## OpenTelemetry Data Collection

          All scenarios have OpenTelemetry enabled for comprehensive metrics:
          - üì° DataDog IAST metrics exported via OTLP
          - üõ°Ô∏è Aikido RASP metrics collected in both modes
          - üìä Prometheus ingesting all telemetry data
          - üìà Grafana dashboards showing real-time comparisons

          ## Thesis Hypothesis Validation

          **Hypothesis:** *RASP provides superior protection by both detecting AND blocking attacks, while IAST provides detection only.*

          **Validation Approach:**
          1. **Scenario 1** demonstrates IAST detection without RASP
          2. **Scenario 2A** shows RASP detection capabilities (non-blocking mode)
          3. **Scenario 2B** proves RASP blocking effectiveness (~80% block rate)

          **Expected Outcome:**
          - Scenarios 1 and 2A: Similar detection counts, 0% blocking
          - Scenario 2B: Same detection counts, ~80% blocking rate
          - **Conclusion:** RASP adds critical blocking layer beyond IAST detection

          ## Data Analysis Locations

          1. üìä **Grafana Dashboard:** http://${{ secrets.EC2_INSTANCE_IP }}:3001
             - View "IAST vs RASP Three-Scenario Comparison"
             - Real-time metrics and historical trends
          
          2. üìà **Prometheus:** http://${{ secrets.EC2_INSTANCE_IP }}:9090
             - Query raw OpenTelemetry metrics
             - Custom metric exploration
          
          3. üîç **DataDog IAST Dashboard**
             - IAST vulnerability detections across all scenarios
             - Trace-level security insights
          
          4. üõ°Ô∏è **Aikido Dashboard**
             - RASP detection and blocking events
             - Attack type breakdown
             - Toggle between detection/blocking modes

          ## Next Steps for Thesis Analysis

          1. ‚úÖ Export metrics from Grafana for statistical analysis
          2. ‚úÖ Compare detection rates across all three scenarios
          3. ‚úÖ Calculate RASP blocking effectiveness (Scenario 2B)
          4. ‚úÖ Analyze response time impact of each configuration
          5. ‚úÖ Document OpenTelemetry data flow architecture
          6. ‚úÖ Generate comparative charts for thesis

          ## Key Metrics to Extract

          - `security_detections_total{scenario="iast-only"}` ‚Üí Baseline IAST detections
          - `security_detections_total{scenario="iast-rasp-detect"}` ‚Üí Combined detection (no blocking)
          - `security_detections_total{scenario="iast-rasp-block"}` ‚Üí Combined detection (with blocking)
          - `security_blocks_total{scenario="iast-rasp-block"}` ‚Üí Actual blocks (should be ~80% of detections)
          - Block Rate = `(blocks / detections) * 100` ‚Üí Key thesis metric

          ---
          
          **üéì Thesis Validation:** This three-scenario approach provides empirical evidence that RASP 
          (Scenario 2B) offers superior protection compared to IAST-only (Scenario 1) or RASP in 
          detection-only mode (Scenario 2A).
          EOF

      - name: Upload Final Comparison Report
        uses: actions/upload-artifact@v4
        with:
          name: comprehensive-three-scenario-analysis
          path: |
            scenario1-*.json
            scenario2a-*.json
            scenario2b-*.json